1 que se passe t il si le retrait echoue on a fait une Verification avant toute modification du coup notre withdraw commence tjrs par verifier les preconditions montant >0 montant <= solde alors si une precondition echoue une exception BusinessRuleViolation est levee immediatement et le solde du compte n est pas modifie

2 que se passe t il si le depot echoue le depot verifie aussi les preconditions avant de modifier le solde exemple montant >0 si ca echoue exception BusinessRuleViolation levee solde pas modifie aucune transaction enregistre

3 comment garantir qu aucune transaction incorrecte n est enregistree on verifie toutes les preconditions avant de toucher au solde et on cree les transactions (TRANSFER_OUT TRANSFER_IN WITHDRAW DEPOSIT) qu apres la mise a jour du solde si erreur rien est ajoute

4 ou placer la logique metier dans Bank ou dans les comptes logique propre a un compte dans Account ou ses sous classes ex solde minimum limite de credit retrait depot valide interest logique qui touche plusieurs comptes dans Bank ex transfert verification que les 2 comptes existent atomicite

TP6 - Réponses aux questions de réflexion

Exercice 1 : BankRepository

Quelles informations doit-on sauvegarder ?

Pour pouvoir reconstruire une Bank complète, nous devons sauvegarder :

1.  Tous les comptes  avec leurs attributs spécifiques :
   - `accountNumber` (identifiant unique)
   - `balance` (solde actuel)
   - Pour `SavingsAccount` : `interestRate`
   - Pour `CreditAccount` : `creditLimit`
   - Pour `BusinessAccount` : `tier` (niveau de service)

2.  L'historique des transactions  de chaque compte :
   - `type` (DEPOSIT, WITHDRAW, FEE, INTEREST, TRANSFER)
   - `amount` (montant)
   - `balanceAfter` (solde après transaction)
   - `timestamp` (horodatage)

3.  Le type exact  de chaque compte pour recréer les bonnes instances

   Doit-on gérer plusieurs banques ou une seule instance globale ?

 Choix retenu  : Une seule instance globale par repository

 Justifications  :
- Simplifie l'implémentation pour ce TP pédagogique
- Correspond au use case réel : une application = une banque
- Si besoin de plusieurs banques : créer plusieurs repositories avec des fichiers différents

   Quels types d'erreurs doivent être encapsulés dans PersistenceException ?

1.  Erreurs d'I/O  (IOException) :
   - Fichier inaccessible, permissions insuffisantes
   - Espace disque insuffisant
   - Problèmes réseau (si stockage distant)

2.  Erreurs de format  :
   - Données corrompues ou incomplètes
   - Format invalide (ligne mal formée)
   - Type de compte inconnu

3.  Erreurs de parsing  :
   - Conversion de types (String → double)
   - Dates invalides
   - Valeurs manquantes

   Pourquoi Bank doit dépendre d'une abstraction plutôt que d'une classe concrète ?

 Principe d'Inversion de Dépendance (SOLID - D)  :

1.  Découplage  : Bank ne connaît pas les détails d'implémentation
   - Peut changer de fichier → base de données sans modifier Bank
   - Peut tester avec un mock repository en mémoire

2.  Flexibilité  : Possibilité d'avoir plusieurs implémentations
   - `FileBankRepository` : persistance fichier
   - `DatabaseBankRepository` : persistance SQL
   - `InMemoryBankRepository` : tests sans I/O

3.  Maintenabilité  : Séparation claire des responsabilités
   - Bank = logique métier
   - Repository = logique de persistance

---

   Exercice 2 : FileBankRepository

   Rôle de FileBankRepository

 Responsabilités  :
- Gérer le transport des données vers/depuis le système de fichiers
- Utiliser `Files.writeString()` et `Files.readString()` de Java NIO
- Encapsuler les IOException dans PersistenceException
-  NE PAS  connaître les détails du format (délégué au serializer)

   Séparation des responsabilités

  
FileBankRepository : "TRANSPORT"
    ↓ délègue à
BankSerializer : "FORMAT"
  

Cette séparation permet de changer le format (texte → JSON → XML) sans toucher au code de transport.

---

   Exercice 3 : Format de sérialisation

   Format texte choisi

  
ACCOUNT;TYPE;ID;BALANCE;PARAM1;PARAM2...
TRANSACTION;ACCOUNT_ID;TYPE;AMOUNT;BALANCE_AFTER;TIMESTAMP
  

 Exemple concret  :
  
ACCOUNT;SAVINGS;SA-1001;1000.0;0.05
ACCOUNT;CREDIT;CR-2001;-200.0;500.0
ACCOUNT;BUSINESS;BA-3001;5000.0;PREMIUM
TRANSACTION;SA-1001;DEPOSIT;200.0;1200.0;2025-12-19T10:30:00
TRANSACTION;CR-2001;WITHDRAW;50.0;-250.0;2025-12-19T11:00:00
  

   Avantages de ce format

1.  Lisible  : Peut être édité manuellement si besoin
2.  Simple  : Pas besoin de bibliothèque externe
3.  Structuré  : Chaque ligne = un objet
4.  Extensible  : Facile d'ajouter de nouveaux types de comptes

   Limitations connues

1.  Transactions  : Les timestamps ne sont pas parfaitement restaurés (Transaction est immutable avec `LocalDateTime.now()`)
2.  Observers et FeePolicy  : Ne sont pas persistés (doivent être reconfigurés après chargement)
3.  Sécurité  : Pas de validation robuste contre les fichiers malveillants

---

   Exercice 4 : Questions de réflexion

   1. Que se passe-t-il si bank.txt n'existe pas encore ?

 Comportement actuel  : `PersistenceException` est levée par `FileBankRepository.load()`

 Solutions possibles  :

 Option A  : Retourner une banque vide
  java
if (!Files.exists(path)) {
    return new Bank(); // État initial
}
  

 Option B  : Créer le fichier vide
  java
if (!Files.exists(path)) {
    Files.createFile(path);
    return new Bank();
}
  

 Option C  : Laisser l'exception (choix retenu)
- Force l'utilisateur à sauvegarder au moins une fois
- Évite les confusions entre "pas encore sauvegardé" et "sauvegarde vide"

   2. Que se passe-t-il si le format est corrompu ?

 Cas possibles  :
- Ligne incomplète : `ACCOUNT;SAVINGS;SA-1` (manque balance et rate)
- Type inconnu : `ACCOUNT;INVESTMENT;...`
- Valeur invalide : `ACCOUNT;SAVINGS;SA-1;ABC;0.05` (ABC n'est pas un double)

 Gestion actuelle  :
  java
throw new PersistenceException("Format de compte invalide");
  

 Améliorations possibles  :
- Logger les lignes ignorées au lieu de tout rejeter
- Sauvegarder une copie de backup avant d'écraser
- Valider le format avant de sauvegarder

 3. Où placer la responsabilité d'interpréter ces erreurs ?

Répartition des responsabilités :

|     Composant     |   Responsabilité  |              Exemples d'erreurs                |
|-------------------|-------------------|------------------------------------------------|
| TextBankSerializer| Format et parsing | Ligne mal formée, type inconnu, parsing double |
| FileBankRepository| I/O et fichiers   |    Fichier manquant, permissions, IOException  |
|  Bank / Account   | Règles métier     |      Solde négatif invalide, montant < 0       |

Principe : Chaque couche gère ses propres erreurs et les encapsule dans PersistenceException pour les couches supérieures.

---

--- Architecture finale

┌─────────────────┐
│      Main       │
└────────┬────────┘
         │
         ↓
┌─────────────────┐
│      Bank       │ (domaine métier)
└────────┬────────┘
         │ dépend de
         ↓
┌─────────────────────┐
│  BankRepository     │ (interface)
└─────────────────────┘
         △
         │ implémente
         │
┌────────┴──────────────┐
│ FileBankRepository    │ (transport)
└──────────┬────────────┘
           │ utilise
           ↓
┌─────────────────────┐
│  BankSerializer     │ (interface)
└─────────────────────┘
         △
         │ implémente
         │
┌────────┴──────────────┐
│ TextBankSerializer    │ (format)
└───────────────────────┘
  

Cette architecture respecte :
- Single Responsibility : Chaque classe a une seule raison de changer
- Open/Closed: Extensible (nouveaux serializers) sans modification
- Dependency Inversion : Bank dépend d'abstractions, pas de détails
- Séparation des concerns: Métier ≠ Persistance ≠ Format